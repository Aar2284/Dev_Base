#chapter1

# **1. Scalability**

### **What it means**

The system’s ability to handle increasing load without degrading performance.

### **Two kinds:**

- **Vertical scaling**  
    Upgrading a single machine. Limited, expensive, straightforward.
    
- **Horizontal scaling**  
    Adding more machines and distributing load. The modern standard.
    

### **Signals of good scalability:**

- Stateless services
    
- Partitioned data
    
- Distributed workloads
    
- No single bottleneck
    

---

# **2. Reliability**

### **Definition**

The system performs correctly, consistently, and predictably.

In other words:

> “Does this system behave as expected, even when users try their best to break it?”

### **Achieved through:**

- Retries + idempotency
    
- Replication
    
- Consistent hashing
    
- Heartbeats & health checks
    
- Graceful degradation
    

---

# **3. Availability**

### **Meaning**

The proportion of time the system is operational.

Expressed as:

- 99.0% → 87 hours downtime/year
    
- 99.9% → 8 hours/year
    
- 99.99% → 52 minutes/year (also known as 4 nines)
    
- 99.999% → 5 minutes/year (rare, expensive, brutal)
    

### **How availability is achieved**

- Redundancy
    
- Multi-zone deployments
    
- Failover mechanisms
    
- Load balancing
    
- Active-active systems
    

---

# **4. Fault Tolerance**

### **Definition**

A system’s ability to continue operating even when components fail.

Failures are not exceptions; they are the default state in distributed systems.

**Amazon famously notes:**  
“The average AWS server fails every day.”

Fault tolerance is built through:

- Replication (leaders & followers)
    
- Quorums
    
- Distributed coordination (Zookeeper/Raft)
    
- Circuit breakers
    
- Timeouts & fallbacks
    

---

# **5. Performance**

### **The twin metrics:**

- **Latency** → speed per request
    
- **Throughput** → volume of requests per second
    

A high-performance system is both fast and voluminous.

### **Tools to achieve it:**

- Caching
    
- Indexing
    
- Sharding
    
- Compression
    
- Parallelism
    
- Batching
    

---

# **6. Maintainability**

### **Definition**

How gracefully a system can be modified, debugged, and extended.

Think of it as ergonomics for engineers.

### **Achieved through:**

- Clean, modular design
    
- Clear data contracts
    
- Documentation
    
- Observability
    
- Testability
    
- Separation of concerns
    

A system that cannot be maintained becomes a liability — a ticking architectural time bomb.

---

# **7. Observability**

A modern essential.

Systems must tell you what they’re experiencing.

### **Three pillars:**

- **Logs** — the system’s diary
    
- **Metrics** — the system’s vitals
    
- **Traces** — the system’s path through components
    

Tools: Grafana, Prometheus, OpenTelemetry, ELK.

---

# **8. Cost Efficiency (a silent pillar)**

Every design has a price.

Cloud architecture is littered with the bones of systems that scaled magnificently and bankrupted the team maintaining them.

### **Cost levers:**

- Storage format
    
- Compression
    
- Tiered storage
    
- Serverless vs provisioned clusters
    
- Autoscaling policies
    

---

# **Why These Pillars Matter in Interviews**

A strong candidate doesn’t just propose a design —  
they **defend** it.

They show:

- why it scales
    
- how it fails
    
- how it recovers
    
- how it performs under stress
    
- how they minimize cost
    

