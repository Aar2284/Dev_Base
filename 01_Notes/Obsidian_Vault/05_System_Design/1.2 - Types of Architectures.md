#chapter1

---

# **1. The Major Architectural Styles**

In the real world, systems primarily fall into a few architectural paradigms. Each has its virtues, each its imperfections.

We begin.

---

# **I. Monolithic Architecture**

The old titanic structure — a single, unified codebase.

### **Characteristics**

- Everything lives in one deployment.
    
- One database, one runtime, one artifact.
    
- Simpler to develop initially.
    

### **Advantages**

- Easy debugging — everything is “in the same room.”
    
- No network overhead.
    
- Simple deployment pipeline.
    

### **Disadvantages**

- Scaling is blunt: you scale the _whole_ application.
    
- Teams collide; deployments become a political event.
    
- Failure in one part can bring down the entire system.
    

### **Used In**

Startups, simple applications, internal tools.

---

# **II. Microservices Architecture**

A constellation of independent services, each responsible for a single domain.

### **Characteristics**

- Each service owns its logic and data.
    
- Communicates via APIs or event streams.
    
- Autonomous scaling and deployment.
    

### **Advantages**

- Teams move independently.
    
- Fault isolation.
    
- Scale specific services as needed.
    

### **Disadvantages**

- Operational complexity increases sharply.
    
- Network failures become common guests.
    
- Observability becomes mandatory, not optional.
    

### **Used In**

Uber, Netflix, Amazon.

---

# **III. Service-Oriented Architecture (SOA)**

The ancestor of microservices — heavy, enterprise-flavored, and laden with governance layers.

Often defined by:

- Enterprise Service Bus (ESB)
    
- Tight contracts
    
- Shared schemas and policies
    

Microservices rebelled against SOA’s bureaucracy.

---

# **IV. Event-Driven Architecture**

Here, systems communicate not through requests, but **events** — messages that signal something happened.

### **Core Components**

- Producers
    
- Consumers
    
- Event brokers (Kafka, Pulsar, Kinesis)
    

### **Advantages**

- Asynchronous, decoupled, resilient
    
- Ideal for real-time data
    
- Enables massive scalability with ease
    

### **Disadvantages**

- Harder to track flows
    
- Ordering and consistency become nuanced
    
- Debugging requires sophistication
    

### **Used In**

Data engineering pipelines, financial systems, IoT, fraud detection, analytics engines.

---

# **V. Dataflow / Pipeline Architecture**

The backbone of data engineering.

### **Characteristics**

- Data moves through stages: Ingest → Process → Store → Serve
    
- DAG-based (Directed Acyclic Graph) orchestration
    
- Tools: Airflow, Dagster, Spark, Flink
    

### **Advantages**

- Modular
    
- Scalable
    
- Highly observable
    

### **Disadvantages**

- Latency can be non-real-time
    
- Job dependency management is complex
    

### **Used In**

ETL, analytics, warehousing, ML feature stores.

---

# **VI. Lambda Architecture**

A hybrid of batch + real-time processing.

### **Layers**

1. Batch layer (Hadoop/Spark)
    
2. Speed layer (Kafka/Flink)
    
3. Serving layer (Presto/Elasticsearch)
    

### **Pros**

- Accuracy + speed
    
- High fault tolerance
    

### **Cons**

- Maintaining two pipelines feels like maintaining two relationships — exhausting.
    

---

# **VII. Kappa Architecture**

A modern simplification: streaming only.

### **Principle**

> One system: the real-time pipeline.  
> For reprocessing? Replay the log.

### **Pros**

- Elegant and unified
    
- Kafka + Flink make this extremely powerful
    

### **Cons**

- Requires a robust stream backbone
    
- Not suitable for all workloads
    

---

# **VIII. Distributed Architecture**

Everything is spread across multiple nodes — classic distributed computing.

### **Core Ideas**

- Replication
    
- Partitioning
    
- Consensus
    
- Leader election
    

Applies to practically all modern systems.

---

# **IX. Serverless Architecture**

Compute without servers — or at least without _your_ servers.

### **Examples**

- AWS Lambda
    
- GCP Cloud Functions
    
- Azure Functions
    

### **Pros**

- Scales automatically
    
- Zero idle cost
    

### **Cons**

- Cold starts
    
- Execution time limits
    
- Debugging is… esoteric
    

---

# **How to Use This in Interviews**

You must be able to:

- Identify the best architecture for a system
    
- Justify why alternatives were rejected
    
- Discuss scaling implications
    
- Mention trade-offs with poise and clarity
    

